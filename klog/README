== rcS ==
1) 从命令行指定的地址获取klog的配置。
    1) 就是一个静态的文件，使用fsh来提供URL。
    2) 通过wget获取就可以了。
        1) 调查一下，为什么获取不下来？
2) 确认是否开启HOOK方式。

== syslog 替换 ==
1) 替换到ntvlog.h文件，新的文件中使用klogf来代替syslog函数
2) 增加一个klog.c到sysutil目录中，几乎和原来的klog一样，例外是需要在第一次调用的时候自动初始化。
3) 自动初始化的时候，首先从/tmp/klog.cfg中读取默认的配置。
4) 自动初始化的时候，同时启动ORServer来动态的配置改变。
5) 自动初始化的时候，获取当前PID对应的进程，并把该消息以普通打印的方式输出到klog远程服务器。
    1) klogf("klog init: pid = %d, commandline: %s\n", getpid(), "/proc/self/cmdline");

== HOOK ==
1) ioctl: 需要打印一个request和真实的request名字的对应表，否则就搞不清楚request到底是什么命令。
2) ioctl: 打印对应的进程和命令行，socket、open、close可能都需要监视，对于open，需要打印相关的路径。
3) ioctl的type就是PI_DEV_ID_XXX，好像有了这个 2) 中所说的HOOK就不需要的，因为类型已经知道了

== klog server ==
1) 在PC端，9000端口监听/接收数据。
    1) 就是opt-rpc-server
2) PC的挨批地址通过盒子启动的命令行传递给盒子的系统。


== /tmp/klog.cfg ==
tss=leftA...

== klog ==
1) 除了每个进程都使用一个单独的ORServer之外，还可以这样
    1) 存在一个单独的daemon，各个klog启动的过程中，向怹注册__g_klog_dirty的地址，
    2) daemon在配置变化的时候，修改各个__g_klog_dirty变量（通过注册的 klog_set_dirty() 函数）
    3) daemon则实现为一个单独的ORServer来实时获取外部的控制。
    
